using System.Text.Json.Serialization;
using Keys = BitzArt.ApiExceptions.ApiExceptionPayload.Keys;

namespace BitzArt.ApiExceptions;

/// <summary>
/// Problem Details, as defined in RFC 7807.
/// </summary>
public class ProblemDetails
{
    private static IEnumerable<string> ReservedKeys => new List<string>
    {
        Keys.Title,
        Keys.ErrorType,
        Keys.Detail,
        Keys.Instance
    };

    /// <summary>
    /// Provides a short, human-readable summary of the problem.
    /// </summary>
    [JsonPropertyName(Keys.Title)]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Title { get; set; }

    /// <summary>
    /// The HTTP status code generated by the origin server for this occurrence of the problem.
    /// </summary>
    [JsonPropertyName(Keys.Status)]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? Status { get; set; }

    /// <summary>
    /// A URI reference [RFC3986] that identifies the problem type.
    /// </summary>
    [JsonPropertyName(Keys.ErrorType)]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? ErrorType { get; set; }

    /// <summary>
    /// A human-readable explanation specific to this occurrence of the problem.
    /// </summary>
    [JsonPropertyName(Keys.Detail)]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Detail { get; set; }

    /// <summary>
    /// A URI reference that identifies the specific occurrence of the problem.
    /// It may or may not yield further information if dereferenced.
    /// </summary>
    [JsonPropertyName(Keys.Instance)]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Instance { get; set; }

    /// <summary>
    /// Additional response data.
    /// </summary>
    [JsonExtensionData]
    public IDictionary<string, object> Extensions { get; set; }

    /// <summary>
    /// Creates a new instance of <see cref="ProblemDetails"/> from an <see cref="ApiExceptionBase">ApiException</see>.
    /// </summary>
    /// <param name="exception">The exception indicating an API error</param>
    /// <param name="addInner">Whether or not to parse inner exceptions</param>
    public ProblemDetails(ApiException exception, bool addInner = false)
        : this(exception, exception.Payload.Data, addInner)
    {
    }

    /// <summary>
    /// Creates a new instance of <see cref="ProblemDetails"/> from an <see cref="Exception"/>.
    /// </summary>
    /// <param name="exception">The exception indicating an API error</param>
    /// <param name="data">Additional response data</param>
    /// <param name="addInner">Whether or not to parse inner exceptions</param>
    public ProblemDetails(Exception exception, IDictionary<string, object>? data = null, bool addInner = false)
        : this(exception.Message, data)
    {
        if (addInner)
        {
            var dict = AddInner(exception);
            if (dict is null) return;
            Extensions.Add("inner", dict);
        }
    }

    // Adds inner exceptions recursively
    private static Dictionary<string, object>? AddInner(Exception exception)
    {
        var inner = exception.InnerException;

        if (inner is null) return null;
        var dict = new Dictionary<string, object>
        {
            { "title", inner.Message }
        };

        var next = AddInner(inner);
        if (next is not null) dict["inner"] = next;

        return dict;
    }

    /// <summary>
    /// Creates a new instance of <see cref="ProblemDetails"/> with a specified error message.
    /// </summary>
    /// <param name="message">The error message</param>
    /// <param name="data">Additional response data</param>
    public ProblemDetails(string? message = null, IDictionary<string, object>? data = null)
    {
        Extensions = new Dictionary<string, object>();
        ParseData(data);
        if (!string.IsNullOrWhiteSpace(message)) Title = message;
    }

    private void ParseData(IDictionary<string, object>? data)
    {
        if (data is null) return;

        if (data.TryGetValue(Keys.ErrorType, out object? errorType)) ErrorType = (string)errorType;
        if (data.TryGetValue(Keys.Detail, out object? detail)) Detail = (string)detail;
        if (data.TryGetValue(Keys.Instance, out object? instance)) Instance = (string)instance;

        foreach (var entry in data)
        {
            if (ReservedKeys.Contains(entry.Key)) continue;
            Extensions.Add(entry.Key, entry.Value);
        }
    }
}
